"use strict";(self.webpackChunkredacted=self.webpackChunkredacted||[]).push([[716],{5122:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"type":"mdx","permalink":"/redacted/development","source":"@site/src/pages/development.md","title":"Development","description":"Project Structure","frontMatter":{},"unlisted":false}');var r=t(4848),s=t(8453);const l={},c="Development",d={},o=[{value:"Project Structure",id:"project-structure",level:2},{value:"Redacted Scala Compiler Plugin",id:"redacted-scala-compiler-plugin",level:2},{value:"<code>resources</code> folder",id:"resources-folder",level:3},{value:"<code>scala</code> folder",id:"scala-folder",level:3},{value:"<code>RuntimeApi</code>",id:"runtimeapi",level:4},{value:"<code>ReporterApi</code>",id:"reporterapi",level:4},{value:"<code>RedactedApi</code>",id:"redactedapi",level:4},{value:"<code>scala-2</code> and <code>scala-3</code> folders",id:"scala-2-and-scala-3-folders",level:3},{value:"<code>test</code> folder",id:"test-folder",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"development",children:"Development"})}),"\n",(0,r.jsx)(n.h2,{id:"project-structure",children:"Project Structure"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"@redacted"})," repository is composed of multiple SBT subprojects:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"./library"}),", which contains the actual ",(0,r.jsx)(n.code,{children:"@redacted"})," annotation definition"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"./plugin"}),", which contains the scala compiler plugin logic for redacted (we will see this in detail below)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"./redacted-docs"}),", which contains the source of redacted GitHub website (using ",(0,r.jsx)(n.a,{href:"http://docusaurus.io/",children:"docusaurus"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"./test"}),", which contains a battery of tests that will be run across multiple Scala versions"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["We won't be seeing the structure of ",(0,r.jsx)(n.code,{children:"./library"})," since it contains a one-liner annotation definition, nor\n",(0,r.jsx)(n.code,{children:"./redacted-docs"}),", since it's outside the scope of this guide and there are plenty of excellent resources on building\nsites with docusaurus and integrate them with SBT and GitHub."]}),"\n",(0,r.jsx)(n.h2,{id:"redacted-scala-compiler-plugin",children:"Redacted Scala Compiler Plugin"}),"\n",(0,r.jsxs)(n.p,{children:["As we just discussed, ",(0,r.jsx)(n.code,{children:"./plugin"})," hosts the bulk of the Scala compiler plugin logic that is responsible for"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["register itself as a valid Scala (both ",(0,r.jsx)(n.code,{children:"2.x"})," and ",(0,r.jsx)(n.code,{children:"3.x"}),") compiler plugin"]}),"\n",(0,r.jsx)(n.li,{children:"analyse the typed AST that the scala compiler is currently compiling"}),"\n",(0,r.jsxs)(n.li,{children:["override, if the necessary conditions are met, the original ",(0,r.jsx)(n.code,{children:"toString"})," in order to hide the ",(0,r.jsx)(n.code,{children:"@redacted"})," fields"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["As you might know, Scala ",(0,r.jsx)(n.code,{children:"2.x"})," and ",(0,r.jsx)(n.code,{children:"3.x"}),' have different compiler plugin APIs, therefore "writing one single codebase\nto rule them all" doesn\'t apply here.']}),"\n",(0,r.jsx)(n.p,{children:"However, there are some similarities and commonalities that can be extracted and generalised: we will see them in a\nshort while, case-by-case."}),"\n",(0,r.jsxs)(n.h3,{id:"resources-folder",children:[(0,r.jsx)(n.code,{children:"resources"})," folder"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"https://github.com/polentino/redacted/tree/main/plugin/src/main/resources",children:"resources"})," folder contains the\nconfiguration files needed to register redacted compiler plugin itself into the Scala compiler:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"scalac-plugin.xml"})," is the configuration file needed for Scala ",(0,r.jsx)(n.code,{children:"2.x"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"plugin.properties"})," is the configuration file needed for Scala ",(0,r.jsx)(n.code,{children:"3.x"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"They are bundled all together in the same artifact (after all, depending on the Scala runtime, only one will be\nrecognised)."}),"\n",(0,r.jsxs)(n.h3,{id:"scala-folder",children:[(0,r.jsx)(n.code,{children:"scala"})," folder"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"https://github.com/polentino/redacted/tree/main/plugin/src/main/scala",children:"src/main/scala"})," folder contains the Scala\nversion-agnostic sources of the compiler plugin: they expose the generic interfaces and data types needed for the\ncompiler plugin to work, and abstract the logic to determine if the ",(0,r.jsx)(n.code,{children:"Tree"})," being currently analysed by the Scala\ncompiler needs to be patched."]}),"\n",(0,r.jsx)(n.h4,{id:"runtimeapi",children:(0,r.jsx)(n.code,{children:"RuntimeApi"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"RuntimeApi"})," is the main trait that needs to be implemented for each Scala version."]}),"\n",(0,r.jsxs)(n.p,{children:["It contains the types definitions that it requires in order to work properly, such as ",(0,r.jsx)(n.code,{children:"Tree"}),", ",(0,r.jsx)(n.code,{children:"DefDef"}),", ",(0,r.jsx)(n.code,{children:"Symbol"})," and so\non, as well the abstract method definitions that needs to be implemented to work properly, for example ",(0,r.jsx)(n.code,{children:"caseClassOwner"}),"\nwhich, given a ",(0,r.jsx)(n.code,{children:"Tree"})," as parameter, returns an ",(0,r.jsx)(n.code,{children:"Option[Symbol]"})," describing the case class that is associated to it, if\nany."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",metastring:'title="RuntimeApi.scala"',children:"trait RuntimeApi { self =>\n  // ...\n  protected val reporterApi: ReporterApi[self.type]\n  type Tree\n  type DefDef <: Tree\n  // ... // more types & bulk of the logic\n  \n  // ... // abstract methods that need to be implemented in the specific Scala version\n  protected def caseClassOwner(tree: Tree): Option[Symbol]\n  protected def extractToString(tree: Tree): Option[DefDef]\n  protected def redactedFields(owner: Symbol): Option[List[Symbol]]\n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["It also contains methods, such as ",(0,r.jsx)(n.code,{children:"process"}),", ",(0,r.jsx)(n.code,{children:"validate"})," and ",(0,r.jsx)(n.code,{children:"createToStringBody"}),", which are using those abstract methods\nto build the whole core of the plugin:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"validate"})," makes sure that:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["the ",(0,r.jsx)(n.code,{children:"Tree"})," under analysis correspond to a ",(0,r.jsx)(n.code,{children:"toString"})," method"]}),"\n",(0,r.jsx)(n.li,{children:"tries to return its case class owner, if any"}),"\n",(0,r.jsx)(n.li,{children:"tries to retrieve all the owner's redacted fields"}),"\n",(0,r.jsx)(n.li,{children:"bundles the results together, if the all the checks pass"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"createToStringBody"})," uses the results of the validation step to build the AST equivalent to the redacted ",(0,r.jsx)(n.code,{children:"toString"}),"\nmethod"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"process"})," puts the steps above together, and prints an error report in case something went wrong"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"reporterapi",children:(0,r.jsx)(n.code,{children:"ReporterApi"})}),"\n",(0,r.jsxs)(n.p,{children:["There's also a small utility, ",(0,r.jsx)(n.code,{children:"ReporterApi"}),", to generalise the reporter functionality that is present in the Scala ",(0,r.jsx)(n.code,{children:"2.x"}),"\nand ",(0,r.jsx)(n.code,{children:"3.x"})," versions."]}),"\n",(0,r.jsx)(n.h4,{id:"redactedapi",children:(0,r.jsx)(n.code,{children:"RedactedApi"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"RedactedApi"})," is a small utility class to deal with path-dependent types which ",(0,r.jsx)(n.code,{children:"RuntimeApi"})," holds (via a convenient\n",(0,r.jsx)(n.code,{children:"apply()"})," method in its companion object), exposing a single method ",(0,r.jsx)(n.code,{children:"process(..)"})," that will invoke the underlying\n",(0,r.jsx)(n.code,{children:"RuntimeApi"}),"."]}),"\n",(0,r.jsxs)(n.h3,{id:"scala-2-and-scala-3-folders",children:[(0,r.jsx)(n.code,{children:"scala-2"})," and ",(0,r.jsx)(n.code,{children:"scala-3"})," folders"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"https://github.com/polentino/redacted/tree/main/plugin/src/main/scala-2",children:"src/main/scala-2"})," and\n",(0,r.jsx)(n.a,{href:"https://github.com/polentino/redacted/tree/main/plugin/src/main/scala-3",children:"src/main/scala-3"})," folder contains Scala\nversion specific implementation of the ",(0,r.jsx)(n.code,{children:"RedactedApi"}),", ",(0,r.jsx)(n.code,{children:"RuntimeApi"})," and ",(0,r.jsx)(n.code,{children:"ReporterApi"}),", defining the proper types and\nimplementing the abstract methods needed for the main logic in ",(0,r.jsx)(n.code,{children:"RedactedApi"})," to work, for example"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",metastring:'title="scala-2/.../Scala2Runtime.scala"',children:"trait Scala2Runtime[GlobalRef <: Global] extends RuntimeApi {\n  protected val theGlobal: GlobalRef\n  override type Tree = theGlobal.Tree\n  override type DefDef = theGlobal.DefDef\n  // .. more type defs\n\n  override protected def caseClassOwner(tree: Tree): Option[Symbol] =\n    Option(tree.symbol).collectFirst { case symbol if symbol.owner.isCaseClass => symbol.owner }\n  // .. // more methods impl\n}\n\nobject Scala2Runtime {\n\n  def create(global: Global): Scala2Runtime[global.type] = new Scala2Runtime[global.type] { self =>\n    override protected val theGlobal: global.type = global\n\n    override protected val reporterApi: ReporterApi[self.type] = new ReporterApi[self.type] {\n      protected val runtime: self.type = self\n\n      override def echo(message: String): Unit = theGlobal.reporter.echo(message)\n      override def warning(message: String, pos: runtime.Position): Unit = theGlobal.reporter.warning(pos, message)\n    }\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"test-folder",children:[(0,r.jsx)(n.code,{children:"test"})," folder"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"tests"})," subproject contains the battery of tests that will be run across different versions of Scala."]}),"\n",(0,r.jsxs)(n.p,{children:["Since we want to test the latest version of the compiler plugin, we cannot add a sbt dependecy as we usually do but,\nrather, tweak a bit the ",(0,r.jsx)(n.code,{children:"scalac"})," options like so"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'Test / scalacOptions ++= {\n  val addScala2Plugin = "-Xplugin-require:redacted-plugin"\n  val jar = (redactedCompilerPlugin / Compile / packageBin).value\n  val addScala3Plugin = "-Xplugin:" + jar.getAbsolutePath\n  val dummy = "-Jdummy=" + jar.lastModified\n  Seq(addScala2Plugin, addScala3Plugin, dummy)\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This will tell ",(0,r.jsx)(n.code,{children:"scalac"})," to include redacted compiler plugin using both the Scala ",(0,r.jsx)(n.code,{children:"2.x"})," and ",(0,r.jsx)(n.code,{children:"3.x"})," syntax (only one\nwill be used, while the other will be ignored depending on the Scala runtime currently in use), and the ",(0,r.jsx)(n.code,{children:"dummy"})," command\nline option is to make sure the whole ",(0,r.jsx)(n.code,{children:"scalacOptions"})," gets re-evaluated every time ",(0,r.jsx)(n.code,{children:"redactedCompilerPlugin"})," project\nchanges, ensuring to run the tests against the most recent version of the plugin."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>c});var i=t(6540);const r={},s=i.createContext(r);function l(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);